<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Defining the classes LevelSetKDEx and LevelSetKDEx_kNN which turn any point predictor into a conditional kernel density estimator.">

<title>dddex - Level-Set Based Kernel Density Estimation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="dddex - Level-Set Based Kernel Density Estimation">
<meta property="og:description" content="Defining the classes LevelSetKDEx and LevelSetKDEx_kNN which turn any point predictor into a conditional kernel density estimator.">
<meta property="og:site-name" content="dddex">
<meta name="twitter:title" content="dddex - Level-Set Based Kernel Density Estimation">
<meta name="twitter:description" content="Defining the classes LevelSetKDEx and LevelSetKDEx_kNN which turn any point predictor into a conditional kernel density estimator.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">dddex</span>
    </a>
  </div>
        <div class="quarto-navbar-tools ms-auto">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./levelsetkdex_univariate.html">Level-Set Based Kernel Density Estimation</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">dddex: Data-Driven Density Estimation x</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./baseclasses.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Base Class</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./levelsetkdex_univariate.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Level-Set Based Kernel Density Estimation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./levelsetkdex_multivariate.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Level-Set Based Kernel Density Estimation for multivariate Predictors</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./wsaa.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">wSAA</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./crossvalidation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Cross Validation Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./utils.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Helper Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./loaddata.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Load Datasets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./99_unitTests.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Generate Neighborhoods</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#level-set-approach-based-on-bin-building" id="toc-level-set-approach-based-on-bin-building" class="nav-link active" data-scroll-target="#level-set-approach-based-on-bin-building">Level-Set Approach based on Bin Building</a>
  <ul class="collapse">
  <li><a href="#levelsetkdex" id="toc-levelsetkdex" class="nav-link" data-scroll-target="#levelsetkdex">LevelSetKDEx</a></li>
  <li><a href="#levelsetkdex.fit" id="toc-levelsetkdex.fit" class="nav-link" data-scroll-target="#levelsetkdex.fit">LevelSetKDEx.fit</a></li>
  <li><a href="#levelsetkdex.getweights" id="toc-levelsetkdex.getweights" class="nav-link" data-scroll-target="#levelsetkdex.getweights">LevelSetKDEx.getWeights</a></li>
  <li><a href="#generatebins" id="toc-generatebins" class="nav-link" data-scroll-target="#generatebins">generateBins</a></li>
  </ul></li>
  <li><a href="#level-set-approach-based-on-drf" id="toc-level-set-approach-based-on-drf" class="nav-link" data-scroll-target="#level-set-approach-based-on-drf">Level-Set Approach based on DRF</a></li>
  <li><a href="#level-set-approach-based-on-gaussian-kernel" id="toc-level-set-approach-based-on-gaussian-kernel" class="nav-link" data-scroll-target="#level-set-approach-based-on-gaussian-kernel">Level-Set Approach based on Gaussian Kernel</a>
  <ul class="collapse">
  <li><a href="#levelsetkdex_rbf" id="toc-levelsetkdex_rbf" class="nav-link" data-scroll-target="#levelsetkdex_rbf">LevelSetKDEx_RBF</a></li>
  </ul></li>
  <li><a href="#level-set-approach-based-on-knn" id="toc-level-set-approach-based-on-knn" class="nav-link" data-scroll-target="#level-set-approach-based-on-knn">Level-Set Approach based on kNN</a>
  <ul class="collapse">
  <li><a href="#levelsetkdex_knn" id="toc-levelsetkdex_knn" class="nav-link" data-scroll-target="#levelsetkdex_knn">LevelSetKDEx_kNN</a></li>
  <li><a href="#levelsetkdex_knn.fit" id="toc-levelsetkdex_knn.fit" class="nav-link" data-scroll-target="#levelsetkdex_knn.fit">LevelSetKDEx_kNN.fit</a></li>
  <li><a href="#levelsetkdex_knn.getweights" id="toc-levelsetkdex_knn.getweights" class="nav-link" data-scroll-target="#levelsetkdex_knn.getweights">LevelSetKDEx_kNN.getWeights</a></li>
  </ul></li>
  <li><a href="#level-set-approach-based-on-nn" id="toc-level-set-approach-based-on-nn" class="nav-link" data-scroll-target="#level-set-approach-based-on-nn">Level-Set Approach based on NN</a>
  <ul class="collapse">
  <li><a href="#levelsetkdex_nn" id="toc-levelsetkdex_nn" class="nav-link" data-scroll-target="#levelsetkdex_nn">LevelSetKDEx_NN</a></li>
  <li><a href="#get-neighbors" id="toc-get-neighbors" class="nav-link" data-scroll-target="#get-neighbors">Get Neighbors</a></li>
  <li><a href="#getneighbors" id="toc-getneighbors" class="nav-link" data-scroll-target="#getneighbors">getNeighbors</a></li>
  <li><a href="#get-neighbor-test" id="toc-get-neighbor-test" class="nav-link" data-scroll-target="#get-neighbor-test">Get Neighbor Test</a></li>
  <li><a href="#getneighborstest" id="toc-getneighborstest" class="nav-link" data-scroll-target="#getneighborstest">getNeighborsTest</a></li>
  <li><a href="#get-kernel-values" id="toc-get-kernel-values" class="nav-link" data-scroll-target="#get-kernel-values">Get Kernel Values</a></li>
  <li><a href="#getkernelvalues" id="toc-getkernelvalues" class="nav-link" data-scroll-target="#getkernelvalues">getKernelValues</a></li>
  </ul></li>
  <li><a href="#level-set-approach-based-on-clustering" id="toc-level-set-approach-based-on-clustering" class="nav-link" data-scroll-target="#level-set-approach-based-on-clustering">Level-Set Approach based on Clustering</a>
  <ul class="collapse">
  <li><a href="#levelsetkdex_clustering" id="toc-levelsetkdex_clustering" class="nav-link" data-scroll-target="#levelsetkdex_clustering">LevelSetKDEx_clustering</a></li>
  <li><a href="#levelsetkdex_clustering2" id="toc-levelsetkdex_clustering2" class="nav-link" data-scroll-target="#levelsetkdex_clustering2">LevelSetKDEx_clustering2</a></li>
  </ul></li>
  <li><a href="#test-code" id="toc-test-code" class="nav-link" data-scroll-target="#test-code">Test Code</a></li>
  <li><a href="#lsx-based-on-drf" id="toc-lsx-based-on-drf" class="nav-link" data-scroll-target="#lsx-based-on-drf">LSx based on DRF</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/kaiguender/dddex/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Level-Set Based Kernel Density Estimation</h1>
</div>

<div>
  <div class="description">
    Defining the classes <code>LevelSetKDEx</code> and <code>LevelSetKDEx_kNN</code> which turn any point predictor into a conditional kernel density estimator.
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The autoreload extension is already loaded. To reload it, use:
  %reload_ext autoreload</code></pre>
</div>
</div>
<p>In the following we define the classes <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> and <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> where KDE is short for ‘Kernel Density Estimator’ and the ‘x’ is supposed to signal that both classes can be defined based on any arbitrary point predictor. The name ‘LevelSet’ stems from the fact that every approach presented in this notebook interprets the values of the point forecasts as a similarity measure between samples. The point predictor is specified by the argument <code>estimator</code> and must have a <code>.predict()</code>-method and should have been trained before hand.</p>
<p>Both classes <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> and <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> fulfill the same task: By first running <code>.fit(XTrain, yTrain)</code> and then calling <code>.generateWeights(XTest)</code>, they both output an estimation of the conditional density of every sample specified by ‘XTest’. The basic idea for both approaches is also identical: Suppose we have a single test sample at hand. At first, we compare the value of the point prediction of this sample and the values of the point predictions of the training samples computed via <code>estimator.predict(XTrain)</code> and <code>estimator.predict(XTest)</code>, respectively. Based on this comparison, we select ‘binSize’-many training samples that we deem the most similar to the test sample at hand. The concrete way we select the training samples constitutes the only difference between <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> and <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a>. Finally, the empirical distribution of the y-values of these training samples then acts as our estimation of the conditional distribution.</p>
<p>Further details on how both approaches work approaches can be found below.</p>
<section id="level-set-approach-based-on-bin-building" class="level2">
<h2 class="anchored" data-anchor-id="level-set-approach-based-on-bin-building">Level-Set Approach based on Bin Building</h2>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L31" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="levelsetkdex" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex">LevelSetKDEx</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx (estimator, binSize:int=100, weightsByDistance:bool=False)</code></pre>
</blockquote>
<p><a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> turns any point forecasting model into an estimator of the underlying conditional density. The name ‘LevelSet’ stems from the fact that this approach interprets the values of the point forecasts as a similarity measure between samples. The point forecasts of the training samples are sorted and recursively assigned to a bin until the size of the current bin reaches <code>binSize</code> many samples. Then a new bin is created and so on. For a new test sample we check into which bin its point prediction would have fallen and interpret the training samples of that bin as the empirical distribution function of this test sample.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>estimator</td>
<td></td>
<td></td>
<td>Model with a .fit and .predict-method (implementing the scikit-learn estimator interface).</td>
</tr>
<tr class="even">
<td>binSize</td>
<td>int</td>
<td>100</td>
<td>Size of the bins created while running fit.</td>
</tr>
<tr class="odd">
<td>weightsByDistance</td>
<td>bool</td>
<td>False</td>
<td>Determines behaviour of method <code>getWeights</code>. If False, all weights receive the same <br>value. If True, the distance of the point forecasts is taking into account.</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L71" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="levelsetkdex.fit" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex.fit">LevelSetKDEx.fit</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx.fit (X:numpy.ndarray, y:numpy.ndarray)</code></pre>
</blockquote>
<p>Fit <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> model by grouping the point predictions of the samples specified via <code>X</code> according to their value. Samples are recursively sorted into bins until each bin contains <code>binSize</code> many samples. For details, checkout the function <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#generatebins"><code>generateBins</code></a> which does the heavy lifting.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td>np.ndarray</td>
<td>Feature matrix used by <code>estimator</code> to predict <code>y</code>.</td>
</tr>
<tr class="even">
<td>y</td>
<td>np.ndarray</td>
<td>1-dimensional target variable corresponding to the feature matrix <code>X</code>.</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L123" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="levelsetkdex.getweights" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex.getweights">LevelSetKDEx.getWeights</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx.getWeights (X:numpy.ndarray,
                          outputType:str='onlyPositiveWeights',
                          scalingList:list=None)</code></pre>
</blockquote>
<p>Computes estimated conditional density for each sample specified by <code>X</code>. The concrete structure of each element of the returned list depends on the specified value of <code>outputType</code>:</p>
<ul>
<li><strong>all</strong>: An array with the same length as the number of training samples. Each entry represents the probability of each training sample.</li>
<li><strong>onlyPositiveWeights</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the indices of the corresponding training sample. Only probalities greater than zero are returned. Note: This is the most memory and computationally efficient output type.</li>
<li><strong>summarized</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the corresponding value of <code>yTrain</code>. The probabilities corresponding to identical values of <code>yTrain</code> are aggregated.</li>
<li><strong>cumDistribution</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the corresponding value of <code>yTrain</code>.</li>
<li><strong>cumDistributionSummarized</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the corresponding value of <code>yTrain</code>. The probabilities corresponding to identical values of <code>yTrain</code> are aggregated.</li>
</ul>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td>np.ndarray</td>
<td></td>
<td>Feature matrix for which conditional density estimates are computed.</td>
</tr>
<tr class="even">
<td>outputType</td>
<td>str</td>
<td>onlyPositiveWeights</td>
<td>Specifies structure of the returned density estimates. One of: <br>‘all’, ‘onlyPositiveWeights’, ‘summarized’, ‘cumDistribution’, ‘cumDistributionSummarized’</td>
</tr>
<tr class="odd">
<td>scalingList</td>
<td>list</td>
<td>None</td>
<td>Optional. List with length X.shape[0]. Values are multiplied to the estimated <br>density of each sample for scaling purposes.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>list</strong></td>
<td></td>
<td><strong>List whose elements are the conditional density estimates for the samples specified by <code>X</code>.</strong></td>
</tr>
</tbody>
</table>
<section id="generate-bins" class="level4">
<h4 class="anchored" data-anchor-id="generate-bins">Generate Bins</h4>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L392" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
</section>
<section id="generatebins" class="level3">
<h3 class="anchored" data-anchor-id="generatebins">generateBins</h3>
<blockquote class="blockquote">
<pre><code> generateBins (binSize:int, yPred:numpy.ndarray)</code></pre>
</blockquote>
<p>Used to generate the bin-structure used by <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> to compute density estimations.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>binSize</td>
<td>int</td>
<td>Size of the bins of values of <code>yPred</code> being grouped together.</td>
</tr>
<tr class="even">
<td>yPred</td>
<td>np.ndarray</td>
<td>1-dimensional array of predicted values.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="level-set-approach-based-on-drf" class="level2">
<h2 class="anchored" data-anchor-id="level-set-approach-based-on-drf">Level-Set Approach based on DRF</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| export</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># from drf import drf </span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># class LevelSetKDEx_DRF(BaseWeightsBasedEstimator, BaseLSx):</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">#     """</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#     `LevelSetKDEx` turns any point forecasting model into an estimator of the underlying conditional density.</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#     The name 'LevelSet' stems from the fact that this approach interprets the values of the point forecasts</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#     as a similarity measure between samples. The point forecasts of the training samples are sorted and </span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">#     recursively assigned to a bin until the size of the current bin reaches `binSize` many samples. Then</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     a new bin is created and so on. For a new test sample we check into which bin its point prediction</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">#     would have fallen and interpret the training samples of that bin as the empirical distribution function</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">#     of this test sample.    </span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">#     """</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">#     def __init__(self, </span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">#                  estimator, # Model with a .fit and .predict-method (implementing the scikit-learn estimator interface).</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co">#                  binSize: int=100, # Size of the bins created while running fit.</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">#                  ):</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">#         super(BaseEstimator, self).__init__(estimator = estimator)</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">#         # Check if binSize is integer</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="co">#         if not isinstance(binSize, (int, np.int32, np.int64)):</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co">#             raise ValueError("'binSize' must be an integer!")</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.binSize = binSize</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.yTrain = None</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.yPredTrain = None</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.drf = None</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.fitted = False</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="co">#     #---</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="co">#     def fit(self: LevelSetKDEx_DRF, </span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="co">#             X: np.ndarray, # Feature matrix used by `estimator` to predict `y`.</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="co">#             y: np.ndarray, # 1-dimensional target variable corresponding to the feature matrix `X`.</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a><span class="co">#             ):</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="co">#         """</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a><span class="co">#         Fit `LevelSetKDEx` model by grouping the point predictions of the samples specified via `X`</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a><span class="co">#         according to their value. Samples are recursively sorted into bins until each bin contains</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a><span class="co">#         `binSize` many samples. For details, checkout the function `generateBins` which does the</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a><span class="co">#         heavy lifting.</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a><span class="co">#         """</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a><span class="co">#         # Checks</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a><span class="co">#         if not isinstance(self.binSize, (int, np.int32, np.int64)):</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a><span class="co">#             raise ValueError("'binSize' must be an integer!")</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a><span class="co">#         if self.binSize &gt; y.shape[0]:</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a><span class="co">#             raise ValueError("'binSize' mustn't be bigger than the size of 'y'!")</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a><span class="co">#         if X.shape[0] != y.shape[0]:</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a><span class="co">#             raise ValueError("'X' and 'y' must contain the same number of samples!")</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a><span class="co">#         #---</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a><span class="co">#         try:</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a><span class="co">#             yPred = self.estimator.predict(X)</span></span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a><span class="co">#         except NotFittedError:</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a><span class="co">#             try:</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a><span class="co">#                 self.estimator.fit(X = X, y = y)                </span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a><span class="co">#             except:</span></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a><span class="co">#                 raise ValueError("Couldn't fit 'estimator' with user specified 'X' and 'y'!")</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a><span class="co">#             else:</span></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a><span class="co">#                 yPred = self.estimator.predict(X)</span></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a><span class="co">#         #---</span></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a><span class="co">#         yPred = pd.DataFrame(yPred)</span></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a><span class="co">#         y = pd.Series(y)</span></span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a><span class="co">#         DRF = drf(min_node_size = self.binSize, num_trees = 100, num_features = 1, honesty = False, sample_fraction = 0.5, response_scaling = False, mtry = 1, num_threads = 16)</span></span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a><span class="co">#         DRF.fit(X = yPred, Y = y)</span></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a><span class="co">#         #---</span></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a><span class="co">#         # IMPORTANT: In case 'y' is given as a pandas.Series, we can potentially run into indexing </span></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a><span class="co">#         # problems later on.</span></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.yTrain = y.ravel()</span></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.yPredTrain = yPred</span></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.drf = DRF</span></span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a><span class="co">#         self.fitted = True</span></span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a><span class="co">#     #---</span></span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a><span class="co">#     def getWeights(self: LevelSetKDEx_DRF, </span></span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a><span class="co">#                    X: np.ndarray, # Feature matrix for which conditional density estimates are computed.</span></span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a><span class="co">#                    # Specifies structure of the returned density estimates. One of: </span></span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a><span class="co">#                    # 'all', 'onlyPositiveWeights', 'summarized', 'cumDistribution', 'cumDistributionSummarized'</span></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a><span class="co">#                    outputType: str='onlyPositiveWeights', </span></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a><span class="co">#                    # Optional. List with length X.shape[0]. Values are multiplied to the estimated </span></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a><span class="co">#                    # density of each sample for scaling purposes.</span></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a><span class="co">#                    scalingList: list=None, </span></span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a><span class="co">#                    ) -&gt; list: # List whose elements are the conditional density estimates for the samples specified by `X`.</span></span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a><span class="co">#         # __annotations__ = BaseWeightsBasedEstimator.getWeights.__annotations__</span></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a><span class="co">#         __doc__ = BaseWeightsBasedEstimator.getWeights.__doc__</span></span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a><span class="co">#         if not self.fitted:</span></span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a><span class="co">#             raise NotFittedError("This LevelSetKDEx instance is not fitted yet. Call 'fit' with "</span></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a><span class="co">#                                  "appropriate arguments before trying to compute weights.")</span></span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a><span class="co">#         #---</span></span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a><span class="co">#         yPred = self.estimator.predict(X)</span></span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a><span class="co">#         yPred = pd.DataFrame(yPred)</span></span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a><span class="co">#         weightsArray = self.drf.predict(yPred).weights</span></span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a><span class="co">#         weightsList = list(weightsArray)</span></span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a><span class="co">#         weightsDataList = [(weights[weights &gt; 0], np.where(weights &gt; 0)[0]) for weights in weightsList]</span></span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a><span class="co">#         weightsDataList = restructureWeightsDataList(weightsDataList = weightsDataList, </span></span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                      outputType = outputType, </span></span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                      y = self.yTrain,</span></span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                      scalingList = scalingList,</span></span>
<span id="cb7-120"><a href="#cb7-120" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                      equalWeights = True)</span></span>
<span id="cb7-121"><a href="#cb7-121" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-122"><a href="#cb7-122" aria-hidden="true" tabindex="-1"></a><span class="co">#         return weightsDataList</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="level-set-approach-based-on-gaussian-kernel" class="level2">
<h2 class="anchored" data-anchor-id="level-set-approach-based-on-gaussian-kernel">Level-Set Approach based on Gaussian Kernel</h2>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L433" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="levelsetkdex_rbf" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex_rbf">LevelSetKDEx_RBF</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx_RBF (estimator, lengthScale:float=1)</code></pre>
</blockquote>
<p><a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> turns any point forecasting model into an estimator of the underlying conditional density. The name ‘LevelSet’ stems from the fact that this approach interprets the values of the point forecasts as a similarity measure between samples. The point forecasts of the training samples are sorted and recursively assigned to a bin until the size of the current bin reaches <code>binSize</code> many samples. Then a new bin is created and so on. For a new test sample we check into which bin its point prediction would have fallen and interpret the training samples of that bin as the empirical distribution function of this test sample.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>estimator</td>
<td></td>
<td></td>
<td>Model with a .fit and .predict-method (implementing the scikit-learn estimator interface).</td>
</tr>
<tr class="even">
<td>lengthScale</td>
<td>float</td>
<td>1</td>
<td>Size of the bins created while running fit.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="level-set-approach-based-on-knn" class="level2">
<h2 class="anchored" data-anchor-id="level-set-approach-based-on-knn">Level-Set Approach based on kNN</h2>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L538" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="levelsetkdex_knn" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex_knn">LevelSetKDEx_kNN</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx_kNN (estimator, binSize:int=100,
                   weightsByDistance:bool=False)</code></pre>
</blockquote>
<p><a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> turns any point predictor that has a .predict-method into an estimator of the condititional density of the underlying distribution. The basic idea of each level-set based approach is to interprete the point forecast generated by the underlying point predictor as a similarity measure of samples. In the case of the <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> defined here, for every new samples ‘binSize’-many training samples are computed whose point forecast is closest to the point forecast of the new sample. The resulting empirical distribution of these ‘nearest’ training samples are viewed as our estimation of the conditional distribution of each the new sample at hand.</p>
<p>NOTE: In contrast to the standard <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a>, it is possible to apply <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> to arbitrary dimensional point predictors.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>estimator</td>
<td></td>
<td></td>
<td>Model with a .fit and .predict-method (implementing the scikit-learn estimator interface).</td>
</tr>
<tr class="even">
<td>binSize</td>
<td>int</td>
<td>100</td>
<td>Size of the bins created while running fit.</td>
</tr>
<tr class="odd">
<td>weightsByDistance</td>
<td>bool</td>
<td>False</td>
<td>Determines behaviour of method <code>getWeights</code>. If False, all weights receive the same <br>value. If True, the distance of the point forecasts is taking into account.</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L583" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="levelsetkdex_knn.fit" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex_knn.fit">LevelSetKDEx_kNN.fit</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx_kNN.fit (X:numpy.ndarray, y:numpy.ndarray)</code></pre>
</blockquote>
<p>Fit <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> model by applying the nearest neighbors algorithm to the point predictions of the samples specified by <code>X</code> based on <code>estimator</code>.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td>np.ndarray</td>
<td>Feature matrix used by <code>estimator</code> to predict <code>y</code>.</td>
</tr>
<tr class="even">
<td>y</td>
<td>np.ndarray</td>
<td>1-dimensional target variable corresponding to the feature matrix <code>X</code>.</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L638" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="levelsetkdex_knn.getweights" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex_knn.getweights">LevelSetKDEx_kNN.getWeights</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx_kNN.getWeights (X:numpy.ndarray,
                              outputType:str='onlyPositiveWeights',
                              scalingList:list=None)</code></pre>
</blockquote>
<p>Computes estimated conditional density for each sample specified by <code>X</code>. The concrete structure of each element of the returned list depends on the specified value of <code>outputType</code>:</p>
<ul>
<li><strong>all</strong>: An array with the same length as the number of training samples. Each entry represents the probability of each training sample.</li>
<li><strong>onlyPositiveWeights</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the indices of the corresponding training sample. Only probalities greater than zero are returned. Note: This is the most memory and computationally efficient output type.</li>
<li><strong>summarized</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the corresponding value of <code>yTrain</code>. The probabilities corresponding to identical values of <code>yTrain</code> are aggregated.</li>
<li><strong>cumDistribution</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the corresponding value of <code>yTrain</code>.</li>
<li><strong>cumDistributionSummarized</strong>: A tuple. The first element of the tuple represents the probabilities and the second one the corresponding value of <code>yTrain</code>. The probabilities corresponding to identical values of <code>yTrain</code> are aggregated.</li>
</ul>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td>np.ndarray</td>
<td></td>
<td>Feature matrix for which conditional density estimates are computed.</td>
</tr>
<tr class="even">
<td>outputType</td>
<td>str</td>
<td>onlyPositiveWeights</td>
<td>Specifies structure of the returned density estimates. One of: <br>‘all’, ‘onlyPositiveWeights’, ‘summarized’, ‘cumDistribution’, ‘cumDistributionSummarized’</td>
</tr>
<tr class="odd">
<td>scalingList</td>
<td>list</td>
<td>None</td>
<td>Optional. List with length X.shape[0]. Values are multiplied to the estimated <br>density of each sample for scaling purposes.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>list</strong></td>
<td></td>
<td><strong>List whose elements are the conditional density estimates for the samples specified by <code>X</code>.</strong></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="level-set-approach-based-on-nn" class="level2">
<h2 class="anchored" data-anchor-id="level-set-approach-based-on-nn">Level-Set Approach based on NN</h2>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L725" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="levelsetkdex_nn" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex_nn">LevelSetKDEx_NN</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx_NN (estimator, binSize:int=100, efficientRAM:bool=False)</code></pre>
</blockquote>
<p><a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> turns any point predictor that has a .predict-method into an estimator of the condititional density of the underlying distribution. The basic idea of each level-set based approach is to interprete the point forecast generated by the underlying point predictor as a similarity measure of samples. In the case of the <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> defined here, for every new samples ‘binSize’-many training samples are computed whose point forecast is closest to the point forecast of the new sample. The resulting empirical distribution of these ‘nearest’ training samples are viewed as our estimation of the conditional distribution of each the new sample at hand.</p>
<p>NOTE: In contrast to the standard <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a>, it is possible to apply <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex_knn"><code>LevelSetKDEx_kNN</code></a> to arbitrary dimensional point predictors.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>estimator</td>
<td></td>
<td></td>
<td>Model with a .fit and .predict-method (implementing the scikit-learn estimator interface).</td>
</tr>
<tr class="even">
<td>binSize</td>
<td>int</td>
<td>100</td>
<td>Size of the bins created while running fit.</td>
</tr>
<tr class="odd">
<td>efficientRAM</td>
<td>bool</td>
<td>False</td>
<td>Setting ‘efficientRAM = TRUE’ is only necessary when there are roughly umore than 200k training observations to avoid<br>an overusage of RAM. This setting causes the run-time of the algorithm of the weights computation to linearly depend on <br>‘binSize’. Because of that the algorithm becomes quite slow for ‘binSize’ &gt; 10k’.</td>
</tr>
</tbody>
</table>
</section>
<section id="get-neighbors" class="level3">
<h3 class="anchored" data-anchor-id="get-neighbors">Get Neighbors</h3>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L868" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="getneighbors" class="level3">
<h3 class="anchored" data-anchor-id="getneighbors">getNeighbors</h3>
<blockquote class="blockquote">
<pre><code> getNeighbors (binSize:int, yPred:numpy.ndarray)</code></pre>
</blockquote>
<p>Used to generate the neighboorhoods used by <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> to compute density estimations.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>binSize</td>
<td>int</td>
<td>Size of the bins of values of <code>yPred</code> being grouped together.</td>
</tr>
<tr class="even">
<td>yPred</td>
<td>np.ndarray</td>
<td>1-dimensional array of predicted values.</td>
</tr>
</tbody>
</table>
</section>
<section id="get-neighbor-test" class="level3">
<h3 class="anchored" data-anchor-id="get-neighbor-test">Get Neighbor Test</h3>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L1082" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="getneighborstest" class="level3">
<h3 class="anchored" data-anchor-id="getneighborstest">getNeighborsTest</h3>
<blockquote class="blockquote">
<pre><code> getNeighborsTest (binSize:int, yPred:numpy.ndarray,
                   yPredTrain:numpy.ndarray, neighborsDictTrain:dict)</code></pre>
</blockquote>
<p>Used to generate the neighboorhoods used by <a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> to compute density estimations.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>binSize</td>
<td>int</td>
<td>Size of the bins of values of <code>yPred</code> being grouped together.</td>
</tr>
<tr class="even">
<td>yPred</td>
<td>np.ndarray</td>
<td>1-dimensional array of predicted values.</td>
</tr>
<tr class="odd">
<td>yPredTrain</td>
<td>np.ndarray</td>
<td>1-dimensional array of predicted train values.</td>
</tr>
<tr class="even">
<td>neighborsDictTrain</td>
<td>dict</td>
<td>Dict containing the neighbors of all train samples. Keys are the train predictions.</td>
</tr>
</tbody>
</table>
</section>
<section id="get-kernel-values" class="level3">
<h3 class="anchored" data-anchor-id="get-kernel-values">Get Kernel Values</h3>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L1183" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="getkernelvalues" class="level3">
<h3 class="anchored" data-anchor-id="getkernelvalues">getKernelValues</h3>
<blockquote class="blockquote">
<pre><code> getKernelValues (yPred, yPredTrain, neighborsDictTest,
                  neighborsDictTrain, neighborsRemoved, neighborsAdded,
                  binSize, efficientRAM=False)</code></pre>
</blockquote>
</section>
</section>
<section id="level-set-approach-based-on-clustering" class="level2">
<h2 class="anchored" data-anchor-id="level-set-approach-based-on-clustering">Level-Set Approach based on Clustering</h2>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L1306" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="levelsetkdex_clustering" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex_clustering">LevelSetKDEx_clustering</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx_clustering (estimator, nClusters:int=10)</code></pre>
</blockquote>
<p><a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> turns any point forecasting model into an estimator of the underlying conditional density. The name ‘LevelSet’ stems from the fact that this approach interprets the values of the point forecasts as a similarity measure between samples. The point forecasts of the training samples are sorted and recursively assigned to a bin until the size of the current bin reaches <code>binSize</code> many samples. Then a new bin is created and so on. For a new test sample we check into which bin its point prediction would have fallen and interpret the training samples of that bin as the empirical distribution function of this test sample.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>estimator</td>
<td></td>
<td></td>
<td>Model with a .fit and .predict-method (implementing the scikit-learn estimator interface).</td>
</tr>
<tr class="even">
<td>nClusters</td>
<td>int</td>
<td>10</td>
<td>Number of clusters to form as well as number of centroids to generate.</td>
</tr>
</tbody>
</table>
<hr>
<p><a href="https://github.com/kaiguender/dddex/blob/main/dddex/levelSetKDEx_univariate.py#L1462" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="levelsetkdex_clustering2" class="level3">
<h3 class="anchored" data-anchor-id="levelsetkdex_clustering2">LevelSetKDEx_clustering2</h3>
<blockquote class="blockquote">
<pre><code> LevelSetKDEx_clustering2 (estimator, nClusters:int=10)</code></pre>
</blockquote>
<p><a href="https://kaiguender.github.io/dddex/levelsetkdex_univariate.html#levelsetkdex"><code>LevelSetKDEx</code></a> turns any point forecasting model into an estimator of the underlying conditional density. The name ‘LevelSet’ stems from the fact that this approach interprets the values of the point forecasts as a similarity measure between samples. The point forecasts of the training samples are sorted and recursively assigned to a bin until the size of the current bin reaches <code>binSize</code> many samples. Then a new bin is created and so on. For a new test sample we check into which bin its point prediction would have fallen and interpret the training samples of that bin as the empirical distribution function of this test sample.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>estimator</td>
<td></td>
<td></td>
<td>Model with a .fit and .predict-method (implementing the scikit-learn estimator interface).</td>
</tr>
<tr class="even">
<td>nClusters</td>
<td>int</td>
<td>10</td>
<td>Number of clusters to form as well as number of centroids to generate.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="test-code" class="level1">
<h1>Test Code</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"># data, XTrain, yTrain, XTest, yTest = loadDataBakery(returnXY = True)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"># LGBM = LGBMRegressor(n_jobs = 1).fit(XTrain, yTrain)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx_drf = LevelSetKDEx_DRF(estimator = LGBM, binSize = 100)</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx_drf.fit(XTrain, yTrain)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co"># weightsDataList = LSKDEx_drf.getWeights(XTest)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"># import time</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co"># start = time.time()</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx = LevelSetKDEx(estimator = LGBM, binSize = 100)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx.fit(XTrain, yTrain)</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co"># weights = LSKDEx.getWeights(XTest)</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co"># print(time.time() - start)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="lsx-based-on-drf" class="level1">
<h1>LSx based on DRF</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"># import ipdb</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># from lightgbm import LGBMRegressor</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"># from xgboost import XGBRegressor</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co"># from dddex.loadData import *</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># from dddex.wSAA import RandomForestWSAA, SampleAverageApproximation</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co"># import time </span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co"># import psutil</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co"># import os</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="co"># import sys</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co"># from drf import drf</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># data, XTrain, yTrain, XTest, yTest = loadDataBakery(returnXY = True)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co"># LGBM = LGBMRegressor(n_jobs = 1).fit(XTrain, yTrain)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx = LevelSetKDEx_RBF(estimator = LGBM, lengthScale = 1)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx.fit(XTrain, yTrain)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># weightsData = LSKDEx.getWeights(XTest[100:200], outputType = 'summarized')</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"># data, XTrain, yTrain, XTest, yTest = loadDataYaz(returnXY = True)</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co"># LGBM = LGBMRegressor(n_jobs = 1).fit(XTrain, yTrain)</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTrain = LGBM.predict(XTrain)</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTest = LGBM.predict(XTest)</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTrain = pd.DataFrame(yPredTrain)</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTest = pd.DataFrame(yPredTest)</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="co"># yTrain = pd.Series(yTrain)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co"># DRF = drf(min_node_size = 100, num_trees = 500, num_features = 1, honesty = False, sample_fraction = 0.5, response_scaling = False, mtry = 1, num_threads = 1)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co"># DRF.fit(yPredTrain, yTrain)</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co"># weights = DRF.predict(yPredTest).weights</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># # Get statistic of weights of first row#</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># weightsRow = weights[0]</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co"># pd.Series(weightsRow[weightsRow &gt; 0]).describe()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>count    366.000000
mean       0.002732
std        0.002423
min        0.000020
25%        0.000590
50%        0.001994
75%        0.004667
max        0.009120
dtype: float64</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import time</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co"># start = time.time()</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx = LevelSetKDEx_clustering2(estimator = LGBM, nClusters = 100)</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx.fit(XTrain, yTrain)</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co"># weights = LSKDEx.getWeights(XTest)</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co"># print(time.time() - start)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># path = '/home/kagu/SID/data/dataSID.csv'</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co"># data = pd.read_csv(path)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co"># ids = data.id.unique()[0:30]</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co"># filtering = [ID in ids for ID in data.id]</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co"># data = data[filtering]</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="co"># X = np.array(data.drop(['demand', 'date', 'id', 'label'], axis = 1))</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Y = np.array(data['demand'])</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="co"># indicesTrain = data['label'] == 'train'</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="co"># indicesTest = data['label'] == 'test'</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="co"># XTrain = X[indicesTrain]</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="co"># yTrain = Y[indicesTrain]</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="co"># XTest = X[indicesTest]</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="co"># yTest = Y[indicesTest]</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="co"># dataTrain = data[indicesTrain]</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a><span class="co"># dataTest = data[indicesTest]</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a><span class="co"># scalingList = dataTest['scalingValue'].tolist()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># data.shape</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># process = psutil.Process(os.getpid())</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"Memory used by Jupyter notebook: {process.memory_info().rss / 2**20:.2f} MB")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># LGBM = LGBMRegressor(boosting_type = 'gbdt',</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">#                      n_jobs = 1)</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co"># LGBM.fit(X = XTrain, y = yTrain)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># start = time.time()</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx = LevelSetKDEx(estimator = LGBM, binSize = 5000)</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx.fit(XTrain, yTrain)</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"># print(time.time() - start)</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTrain = LSKDEx.yPredTrain</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTrain[LSKDEx.neighborsDictTrain[list(LSKDEx.neighborsDictTrain.keys())[100]]]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTrain[LSKDEx.neighborsDictTrain[np.array(list(LSKDEx.neighborsDictTrain.keys()))[-1]]]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># weights = LSKDEx.getWeights(XTest, efficientRAM = True)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># res = LSKDEx.predict(XTest,</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">#                      probs = [0.1, 0.5], </span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co">#                      scalingList = scalingList)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># process = psutil.Process(os.getpid())</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"Memory used by Jupyter notebook: {process.memory_info().rss / 2**20:.2f} MB")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># XTrainMod = XTrain[0:10000]</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co"># yTrainMod = yTrain[0:10000]</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co"># XTestMod = XTest[0:10]</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTrainMod = LGBM.predict(XTrainMod)</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTestMod = LGBM.predict(XTestMod)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx = LevelSetKDEx(estimator = LGBM, binSize = 100, weightsByDistance = False)</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="co"># LSKDEx.fit(XTrainMod, yTrainMod)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %%timeit</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="co"># res = LSKDEx.solveKernelGLS(X = XTrainMod, sigma = 0.5, c = yPredTrainMod)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %%timeit</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co"># #| hide</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co"># res = LSKDEx.getKernelVectorProduct(X1 = XTrainMod, c = yPredTrainMod)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %%timeit</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co"># mean, cov = LSKDEx.getGaussianPosterior(XTrain = XTrainMod, </span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co">#                                         XTest = XTestMod,</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co">#                                         yTrain = yTrainMod,</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">#                                         sigma = 0.5)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTest = LSKDEx.estimator.predict(XTest)</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co"># binPerPredTest = np.searchsorted(a = LSKDEx.lowerBoundPerBin, v = yPredTest, side = 'right') - 1</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co"># binVectorsTest = [(binPerPredTest == i).reshape(-1, 1) * 1 for i in range(len(LSKDEx.lowerBoundPerBin))]</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co"># binVectorsToSliceTest = [np.where(binVector)[0] for binVector in binVectorsTest]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># v = binVectorsToSliceTest[2]</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co"># cov[v[:, None],  v]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># v</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pd.Series(np.ravel(mean)).describe()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pd.Series(yTest).describe()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># yPred = np.concatenate([np.arange(5000)] * 2, axis = 0)</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co"># yPredTrain = np.concatenate([np.arange(50000)] * 2, axis = 0)</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co"># binSize = 200</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co"># neighborsDictTrain, neighborsRemoved, neighborsAdded = generateNeighborhoodsUnique(binSize = binSize,</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                                                yPred = yPredTrain)</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="co"># neighborsDictTest = generateNeighborhoodsTestUnique(binSize = binSize,</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                 yPred = yPred,</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                 yPredTrain = yPredTrain,</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="co">#                                                 neighborsDictTrain = neighborsDictTrain)</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="co"># start = time.time()</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a><span class="co"># kernelValuesList = getKernelValues(binSize = binSize,</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a><span class="co">#                                    yPred = yPred,</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a><span class="co">#                                    yPredTrain = yPredTrain,</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a><span class="co">#                                    neighborsDictTest = neighborsDictTest,</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a><span class="co">#                                    neighborsDictTrain = neighborsDictTrain,</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a><span class="co">#                                    neighborsRemoved = neighborsRemoved,</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a><span class="co">#                                    neighborsAdded = neighborsAdded)</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a><span class="co"># print(time.time() - start)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>